/*
 * src/bin/pg_autoctl/pghba.c
 *	 Functions for manipulating pg_hba.conf
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the PostgreSQL License.
 *
 */
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#include "postgres_fe.h"
#include "pqexpbuffer.h"

#include "defaults.h"
#include "file_utils.h"
#include "ipaddr.h"
#include "parsing.h"
#include "pgctl.h"
#include "pghba.h"
#include "log.h"


#define HBA_LINE_COMMENT " # Auto-generated by pg_auto_failover"


static int get_database_field(char *destination, HBADatabaseType databaseType,
							  const char *databaseName);
static int convert_ip_to_cidr(char *destination, const char *host);
static int escape_hba_string(char *destination, const char *hbaString);


/*
 * pghba_ensure_host_rule_exists ensures that a host rule exists in the
 * pg_hba file with the given database, username, host and authentication
 * scheme.
 */
bool
pghba_ensure_host_rule_exists(const char *hbaFilePath,
							  HBADatabaseType databaseType,
							  const char *database,
							  const char *username,
							  const char *host,
							  const char *authenticationScheme)
{
	char hbaLine[BUFSIZE];
	char *hbaLineEnd = hbaLine;
	char *currentHbaContents = NULL;
	long currentHbaSize = 0L;
	char *includeLine = NULL;
	PQExpBuffer newHbaContents = NULL;

	hbaLineEnd += sprintf(hbaLineEnd, "host ");
	hbaLineEnd += get_database_field(hbaLineEnd, databaseType, database);
	hbaLineEnd += sprintf(hbaLineEnd, " ");
	if (username)
	{
		hbaLineEnd += escape_hba_string(hbaLineEnd, username);
	}
	else
	{
		hbaLineEnd += sprintf(hbaLineEnd, "all");
	}
	hbaLineEnd += sprintf(hbaLineEnd, " ");
	hbaLineEnd += convert_ip_to_cidr(hbaLineEnd, host);
	hbaLineEnd += sprintf(hbaLineEnd, " %s", authenticationScheme);

	log_debug("Ensuring the HBA file \"%s\" contains the line: %s",
			  hbaFilePath, hbaLine);

	if (!read_file(hbaFilePath, &currentHbaContents, &currentHbaSize))
	{
		/* read_file logs an error */
		return false;
	}

	includeLine = strstr(currentHbaContents, hbaLine);

	/*
	 * If the rule was found and it starts on a new line. We can
	 * skip adding it.
	 */
	if (includeLine != NULL && (includeLine == currentHbaContents ||
								includeLine[-1] == '\n'))
	{
		log_debug("Line already exists in %s, skipping", hbaFilePath);
		free(currentHbaContents);
		return true;
	}

	/* build the new postgresql.conf contents */
	newHbaContents = createPQExpBuffer();
	if (newHbaContents == NULL)
	{
		log_error("Failed to allocate memory");
		free(currentHbaContents);
		return false;
	}

	appendPQExpBufferStr(newHbaContents, currentHbaContents);
	appendPQExpBufferStr(newHbaContents, hbaLine);
	appendPQExpBufferStr(newHbaContents, HBA_LINE_COMMENT "\n");

	/* done with the old postgresql.conf contents */
	free(currentHbaContents);

	/* memory allocation could have failed while building string */
	if (PQExpBufferBroken(newHbaContents))
	{
		log_error("Failed to allocate memory");
		destroyPQExpBuffer(newHbaContents);
		return false;
	}

	/* write the new postgresql.conf */
	if (!write_file(newHbaContents->data, newHbaContents->len, hbaFilePath))
	{
		/* write_file logs an error */
		destroyPQExpBuffer(newHbaContents);
		return false;
	}

	destroyPQExpBuffer(newHbaContents);

	log_debug("Wrote new %s", hbaFilePath);

	return true;
}


/*
 * get_database_field writes the database field to destination according to the
 * databaseType. If the type is HBA_DATABASE_DBNAME then the databaseName is
 * written in quoted form.
 */
static int
get_database_field(char *destination,
				   HBADatabaseType databaseType, const char *databaseName)
{
	int fieldLength = 0;

	switch (databaseType)
	{
		case HBA_DATABASE_ALL:
		{
			fieldLength = sprintf(destination, "all");
			break;
		}

		case HBA_DATABASE_REPLICATION:
		{
			fieldLength = sprintf(destination, "replication");
			break;
		}

		case HBA_DATABASE_DBNAME:
		default:
		{
			fieldLength = escape_hba_string(destination, databaseName);
			break;
		}
	}

	return fieldLength;
}


/*
 * convert_ip_to_cidr checks whether the host is an IP and if so converts
 * it to a CIDR and writes it to destination. Otherwise, convert_ip_to_cidr
 * writes the host directly to the destination.
 */
static int
convert_ip_to_cidr(char *destination, const char *host)
{
	int cidrLength = 0;

	switch (ip_address_type(host))
	{
		case IPTYPE_V4:
		{
			cidrLength = sprintf(destination, "%s/32", host);
			break;
		}

		case IPTYPE_V6:
		{
			cidrLength = sprintf(destination, "%s/128", host);
			break;
		}

		case IPTYPE_NONE:
		default:
		{
			cidrLength = sprintf(destination, "%s", host);
			break;
		}
	}

	return cidrLength;
}


/*
 * escape_hba_string escapes a string that is used in a pg_hba.conf file
 * and writes it to the destination. escape_hba_string returns the number
 * of characters written.
 *
 * While this is not documented, the code in hba.c (next_token) implements
 * two double-quotes as a literal double quote.
 */
static int
escape_hba_string(char *destination, const char *hbaString)
{
	int charIndex = 0;
	int length = strlen(hbaString);
	int escapedStringLength = 0;

	destination[escapedStringLength++] = '"';

	for (charIndex = 0; charIndex < length; charIndex++)
	{
		char currentChar = hbaString[charIndex];
		if (currentChar == '"')
		{
			destination[escapedStringLength++] = '"';
		}

		destination[escapedStringLength++] = currentChar;
	}

	destination[escapedStringLength++] = '"';
	destination[escapedStringLength] = '\0';

	return escapedStringLength;
}


/*
 * pghba_enable_lan_cidr adds our local CIDR network notation (e.g.
 * 192.168.0.0/23) to the HBA file of the PostgreSQL server, so that any node
 * in the local network may connect already.
 *
 * Failure is a warning only.
 *
 * In normal cases, pgdata is NULL and pghba_enable_lan_cidr queries the local
 * PostgreSQL server for the location of its HBA file.
 *
 * When initializing a PostgreSQL cluster in a test environment using
 * PG_REGRESS_SOCK_DIR="" and --listen options, then we have to add an HBA rule
 * before starting PostgreSQL, otherwise we don't have a path to connect to it.
 * In that case we pass in PGDATA and pghba_enable_lan_cidr uses the file
 * PGDATA/pg_hba.conf as the hbaFilePath: we just did `pg_ctl initdb` after
 * all, it should be safe.
 */
bool
pghba_enable_lan_cidr(const char *hbaFilePath,
					  HBADatabaseType databaseType,
					  const char *database,
					  const char *hostname,
					  const char *username,
					  const char *authenticationScheme,
					  PGSQL *pgsql)
{
	char ipAddr[BUFSIZE];
	char cidr[BUFSIZE];

	/* Compute the CIDR notation for our hostname */
	if (!findHostnameLocalAddress(hostname, ipAddr, BUFSIZE))
	{
		log_fatal("Failed to find IP address for hostname \"%s\", "
				  "see above for details",
				  hostname);
		return false;
	}

	if (!fetchLocalCIDR(ipAddr, cidr, BUFSIZE))
	{
		log_warn("Failed to determine network configuration for "
				 "IP address \"%s\", skipping HBA settings", ipAddr);
		return false;
	}

	log_debug("HBA: adding CIDR from hostname \"%s\"", hostname);
	log_debug("HBA: local ip address: %s", ipAddr);
	log_debug("HBA: CIDR address to open: %s", cidr);
	log_info("Granting connection privileges on %s", cidr);

	if (!pghba_ensure_host_rule_exists(hbaFilePath, databaseType, database,
									   username, cidr, authenticationScheme))
	{
		log_error("Failed to add the local network to PostgreSQL HBA file: "
				  "couldn't modify the pg_hba file");
		return false;
	}

	if (!pgsql_reload_conf(pgsql))
	{
		log_error("Failed to reload PostgreSQL configuration for new HBA rule");
		return false;
	}
	return true;
}
